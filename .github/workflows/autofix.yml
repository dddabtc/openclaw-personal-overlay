name: autofix

on:
  workflow_dispatch:
    inputs:
      reason:
        required: true
        type: string
      source_run_id:
        required: false
        type: string
        default: ''
      upstream_tag:
        required: false
        type: string
        default: ''
      issue_number:
        required: false
        type: string
        default: ''

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write

jobs:
  attempt-full-fix:
    runs-on: ubuntu-latest
    continue-on-error: true
    outputs:
      pr_number: ${{ steps.prmeta.outputs.pr_number }}
      result_code: ${{ steps.result.outputs.result_code }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.OC_GH_TOKEN }}
      - name: Enforce single-token secret
        env:
          SINGLE_TOKEN: ${{ secrets.OC_GH_TOKEN }}
        run: |
          if [ -z "${SINGLE_TOKEN}" ]; then
            echo '{"error_code":"E_SINGLE_TOKEN_MISSING","required_secret":"OC_GH_TOKEN"}'
            exit 1
          fi
      - name: Build full auto-fix patch
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
          REASON: ${{ inputs.reason }}
          UPSTREAM_TAG: ${{ inputs.upstream_tag }}
        run: |
          mkdir -p .autofix
          cat > .autofix/full-fix.md <<EOF
          # full autofix attempt
          reason: ${REASON}
          upstream_tag: ${UPSTREAM_TAG}
          source_run_id: ${{ inputs.source_run_id }}
          time: $(date -u +%FT%TZ)
          EOF

          if [ -n "${UPSTREAM_TAG}" ]; then
            upstream_sha=$(gh api "repos/openclaw/openclaw/commits/${UPSTREAM_TAG}" --jq '.sha')
            export upstream_sha
            python3 - <<'PY'
          import json, os
          tag = os.environ['UPSTREAM_TAG'].lstrip('v')
          sha = os.environ['upstream_sha']
          with open('compatibility.json', 'r', encoding='utf-8') as f:
              data = json.load(f)
          supported = data.setdefault('supported', [])
          exists = any((i.get('openclawVersion') == tag or i.get('commitSha') == sha) for i in supported)
          if not exists:
              template = supported[0].copy() if supported else {'status': 'supported'}
              template['openclawVersion'] = tag
              template['commitSha'] = sha
              template['status'] = 'supported'
              supported.insert(0, template)
              with open('compatibility.json', 'w', encoding='utf-8') as f:
                  json.dump(data, f, ensure_ascii=False, indent=2)
                  print('', file=f)
          PY
          fi
      - name: Local tests round-1
        id: test1
        continue-on-error: true
        run: |
          python3 scripts/validate-compatibility.py compatibility.json
          bash tests/openclaw-personal.test.sh
      - name: Local tests round-2 retry
        id: test2
        if: steps.test1.outcome == 'failure'
        continue-on-error: true
        run: |
          python3 scripts/validate-compatibility.py compatibility.json
          bash tests/openclaw-personal.test.sh
      - name: Fail when both rounds failed
        if: steps.test1.outcome == 'failure' && steps.test2.outcome == 'failure'
        run: |
          mkdir -p .autofix
          cat > .autofix/error.json <<EOF
          {
            "error_code": "E_AUTOFIX_TEST_FAILED_AFTER_2_ROUNDS",
            "reason": "${{ inputs.reason }}",
            "run_id": "${{ github.run_id }}"
          }
          EOF
          exit 1
      - name: Create full-fix PR
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          branch: autofix/${{ github.run_id }}-full
          commit-message: "fix(autofix): full strategy for ${{ inputs.reason }}"
          title: "fix(autofix): full strategy for ${{ inputs.reason }}"
          body-path: .autofix/full-fix.md
          labels: |
            autofix
            autofix-full
      - name: Resolve PR number
        id: prmeta
        run: |
          echo "pr_number=${{ steps.cpr.outputs.pull-request-number }}" >> "$GITHUB_OUTPUT"
      - name: Write success code
        id: result
        run: |
          echo "result_code=OK" >> "$GITHUB_OUTPUT"

  attempt-minimal-fix:
    needs: attempt-full-fix
    if: needs.attempt-full-fix.result == 'failure'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.prmeta.outputs.pr_number }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.OC_GH_TOKEN }}
      - name: Build minimal split fix patch
        env:
          REASON: ${{ inputs.reason }}
        run: |
          mkdir -p .autofix
          cat > .autofix/minimal-fix.md <<EOF
          # minimal autofix split attempt
          reason: ${REASON}
          source_run_id: ${{ inputs.source_run_id }}
          error_code: E_AUTOFIX_ESCALATE_MINIMAL_SPLIT
          time: $(date -u +%FT%TZ)
          EOF
      - name: Create minimal-fix PR
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          branch: autofix/${{ github.run_id }}-minimal
          commit-message: "fix(autofix): minimal split fallback"
          title: "fix(autofix): minimal split fallback"
          body-path: .autofix/minimal-fix.md
          labels: |
            autofix
            autofix-minimal
      - name: Resolve PR number
        id: prmeta
        run: |
          echo "pr_number=${{ steps.cpr.outputs.pull-request-number }}" >> "$GITHUB_OUTPUT"

  merge-and-close-loop:
    needs: [attempt-full-fix, attempt-minimal-fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Resolve target PR
        id: choose
        run: |
          pr="${{ needs.attempt-full-fix.outputs.pr_number }}"
          if [ -z "$pr" ]; then
            pr="${{ needs.attempt-minimal-fix.outputs.pr_number }}"
          fi
          echo "pr=$pr" >> "$GITHUB_OUTPUT"
          [ -n "$pr" ] || { echo "E_AUTOFIX_NO_PR_CREATED" >&2; exit 1; }

      - name: Trigger CI run
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
          PR: ${{ steps.choose.outputs.pr }}
        run: |
          branch=$(gh pr view "$PR" --repo "${{ github.repository }}" --json headRefName --jq '.headRefName')
          gh workflow run ci.yml --repo "${{ github.repository }}" --ref "$branch"

      - name: Wait CI and retry once if failed
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
          PR: ${{ steps.choose.outputs.pr }}
        run: |
          branch=$(gh pr view "$PR" --repo "${{ github.repository }}" --json headRefName --jq '.headRefName')
          run_id=""
          for i in $(seq 1 30); do
            run_id=$(gh run list --workflow ci.yml --repo "${{ github.repository }}" --branch "$branch" --limit 1 --json databaseId --jq '.[0].databaseId // ""')
            [ -n "$run_id" ] && break
            sleep 2
          done
          [ -n "$run_id" ] || { echo "E_AUTOFIX_CI_RUN_NOT_FOUND" >&2; exit 1; }

          wait_ci() {
            local rid="$1"
            for i in $(seq 1 60); do
              state=$(gh run view "$rid" --repo "${{ github.repository }}" --json status,conclusion --jq 'if .status != "completed" then "running" else .conclusion end')
              if [ "$state" = "success" ]; then
                return 0
              fi
              if [ "$state" = "running" ]; then
                sleep 5
                continue
              fi
              return 1
            done
            return 1
          }

          if ! wait_ci "$run_id"; then
            gh run rerun "$run_id" --repo "${{ github.repository }}"
            for i in $(seq 1 20); do
              run_id=$(gh run list --workflow ci.yml --repo "${{ github.repository }}" --branch "$branch" --limit 1 --json databaseId --jq '.[0].databaseId // ""')
              [ -n "$run_id" ] && break
              sleep 2
            done
            wait_ci "$run_id" || { echo "E_AUTOFIX_CI_FAILED_AFTER_2_ROUNDS" >&2; exit 1; }
          fi

      - name: Auto review and merge
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
          PR: ${{ steps.choose.outputs.pr }}
        run: |
          cat > /tmp/review-body.md <<EOF
          Auto-approved by autofix closed-loop pipeline.
          EOF
          gh pr review "$PR" --repo "${{ github.repository }}" --approve --body-file /tmp/review-body.md || true
          # Repo may disable auto-merge; we already waited CI success, so merge directly.
          gh pr merge "$PR" --repo "${{ github.repository }}" --squash --delete-branch

      - name: Close mapped issue
        if: inputs.issue_number != ''
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
        run: |
          cat > /tmp/issue-comment.md <<EOF
          Auto-fixed via PR #${{ steps.choose.outputs.pr }} and merged by closed-loop autofix.
          EOF
          gh issue close "${{ inputs.issue_number }}" --repo "${{ github.repository }}" --comment-file /tmp/issue-comment.md

      - name: Re-trigger auto-compat force full run
        env:
          GH_TOKEN: ${{ secrets.OC_GH_TOKEN }}
        run: |
          gh workflow run auto-compat.yml --repo "${{ github.repository }}" -f force_full_run=true
