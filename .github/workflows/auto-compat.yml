name: auto-compat

"on":
  workflow_dispatch: {}
  schedule:
    - cron: '30 */6 * * *'
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'pull_request' && format('pr-{0}', github.event.pull_request.number) || github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' && github.event.action == 'synchronize' }}

jobs:
  discover:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      latest_tag: ${{ steps.discover.outputs.latest_tag }}
      latest_sha: ${{ steps.discover.outputs.latest_sha }}
      already_supported: ${{ steps.check.outputs.already_supported }}
      has_failure_residue: ${{ steps.state.outputs.has_failure_residue }}
    steps:
      - uses: actions/checkout@v4

      - name: Discover latest upstream OpenClaw version + commit
        id: discover
        run: |
          set -euo pipefail
          NPM_META=$(curl -fsSL https://registry.npmjs.org/openclaw/latest)
          NPM_VERSION=$(echo "$NPM_META" | jq -r '.version // empty')
          NPM_GIT_HEAD=$(echo "$NPM_META" | jq -r '.gitHead // empty')
          if [[ -z "$NPM_VERSION" ]]; then
            echo "Failed to resolve npm latest openclaw version" >&2
            exit 1
          fi

          RELEASE_TAG=$(curl -fsSL https://api.github.com/repos/openclaw/openclaw/releases/latest | jq -r '.tag_name // empty')
          if [[ -z "$RELEASE_TAG" ]]; then
            echo "Failed to resolve latest upstream release tag" >&2
            exit 1
          fi

          SHA="$NPM_GIT_HEAD"
          if [[ -z "$SHA" ]]; then
            SHA=$(git ls-remote https://github.com/openclaw/openclaw.git "refs/tags/${RELEASE_TAG}^{}" | awk '{print $1}' | head -n1)
            if [[ -z "$SHA" ]]; then
              SHA=$(git ls-remote https://github.com/openclaw/openclaw.git "refs/tags/${RELEASE_TAG}" | awk '{print $1}' | head -n1)
            fi
          fi
          if [[ -z "$SHA" ]]; then
            echo "Failed to resolve commit for npm/release version" >&2
            exit 1
          fi

          echo "latest_tag=v${NPM_VERSION}" >> "$GITHUB_OUTPUT"
          echo "latest_sha=$SHA" >> "$GITHUB_OUTPUT"

      - name: Read failure residue state
        id: state
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          residue_issue=$(gh issue list --repo "$GITHUB_REPOSITORY" --state open --label auto-compat-failure-residue --limit 1 --json number --jq '.[0].number // empty')
          if [[ -n "$residue_issue" ]]; then
            echo "has_failure_residue=true" >> "$GITHUB_OUTPUT"
            echo "residue_issue=$residue_issue" >> "$GITHUB_OUTPUT"
            echo "failure residue: true (issue #$residue_issue)"
          else
            echo "has_failure_residue=false" >> "$GITHUB_OUTPUT"
            echo "residue_issue=" >> "$GITHUB_OUTPUT"
            echo "failure residue: false"
          fi

      - name: Check if already supported in compatibility.json
        id: check
        run: |
          set -euo pipefail
          TAG='${{ steps.discover.outputs.latest_tag }}'
          SHA='${{ steps.discover.outputs.latest_sha }}'
          VERSION="${TAG#v}"

          if jq -e --arg v "$VERSION" --arg sha "$SHA" '.supported[] | select((.status // "") != "deprecated") | select(.openclawVersion == $v and .commitSha == $sha)' compatibility.json >/dev/null; then
            echo "already_supported=true" >> "$GITHUB_OUTPUT"
          else
            echo "already_supported=false" >> "$GITHUB_OUTPUT"
          fi

  validate-and-pr:
    runs-on: ubuntu-latest
    needs: discover
    if: github.event_name != 'pull_request' && needs.discover.outputs.already_supported != 'true' && needs.discover.outputs.has_failure_residue != 'true'
    env:
      UPSTREAM_TAG: ${{ needs.discover.outputs.latest_tag }}
      UPSTREAM_SHA: ${{ needs.discover.outputs.latest_sha }}
      UPSTREAM_VERSION: ${{ needs.discover.outputs.latest_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup toolchain
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Prepare compatibility candidate patchset dir
        run: |
          set -euo pipefail
          base_dir=$(jq -r '.supported[] | select((.status // "") != "deprecated") | .patchSetDir // empty' compatibility.json | head -n1)

          if [[ -z "$base_dir" ]]; then
            echo "No existing patchSetDir found in compatibility.json" >&2
            exit 1
          fi

          short_sha="${UPSTREAM_SHA:0:12}"
          new_dir="patches/${short_sha}-autocompat"
          mkdir -p "$new_dir"
          mapfile -t patches < <(find "$base_dir" -maxdepth 1 -type f -name '*.patch' | sort)
          if (( ${#patches[@]} == 0 )); then
            echo "No patch files found under $base_dir" >&2
            exit 1
          fi
          cp -a "${patches[@]}" "$new_dir/"
          echo "AUTO_PATCHSET_DIR=$new_dir" >> "$GITHUB_ENV"

      - name: Update compatibility.json with candidate support entry
        run: |
          set -euo pipefail
          version="${UPSTREAM_VERSION#v}"
          sha="${UPSTREAM_SHA}"
          patch_dir="${AUTO_PATCHSET_DIR}"
          entry_id="oc-${version}-${sha:0:12}"
          notes="Auto-candidate generated at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          tmp=$(mktemp)
          jq --arg version "$version" \
             --arg sha "$sha" \
             --arg patch_dir "$patch_dir" \
             --arg entry_id "$entry_id" \
             --arg notes "$notes" \
             '.supported = ([{
                id: $entry_id,
                openclawVersion: $version,
                commitSha: $sha,
                upstreamBaseCommit: $sha,
                overlayHeadCommit: "PENDING_VALIDATION",
                patchSetDir: $patch_dir,
                binaryArtifact: "dist-overlay.tar.gz",
                atlasCompat: {memory_search: "expected", memory_get: "expected"},
                notes: $notes
              }] + [(.supported // [])[] | select(.openclawVersion != $version or .commitSha != $sha)])' \
             compatibility.json > "$tmp"
          mv "$tmp" compatibility.json

      - name: Validate compatibility matrix
        run: scripts/validate-compatibility.py compatibility.json

      - name: Checkout upstream openclaw at candidate commit
        uses: actions/checkout@v4
        with:
          repository: openclaw/openclaw
          ref: ${{ env.UPSTREAM_SHA }}
          path: work
          fetch-depth: 0

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git -C ./work config user.name "github-actions[bot]"
          git -C ./work config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Apply overlay patch set (hard fail)
        run: |
          set -euo pipefail
          OVERLAY_CI_ONLY_APPLY=1 ./scripts/apply-personal-patch.sh ./work

      - name: Install dependencies for upstream workspace
        run: |
          cd work
          pnpm install --frozen-lockfile --ignore-scripts

      - name: Run overlay build smoke (required)
        run: |
          cd work
          pnpm -s build

      - name: Build dist overlay artifact
        run: |
          scripts/build-dist-overlay.sh ./work dist-overlay
          mkdir -p out
          mv dist-overlay dist-overlay.tar.gz dist-overlay.tar.gz.sha256 out/

      - name: Fill overlayHeadCommit in compatibility.json
        run: |
          set -euo pipefail
          head_sha=$(git -C work rev-parse HEAD)
          version="${UPSTREAM_VERSION#v}"
          sha="${UPSTREAM_SHA}"
          tmp=$(mktemp)
          jq --arg version "$version" --arg sha "$sha" --arg head "$head_sha" '(.supported // []) |= map(if .openclawVersion == $version and .commitSha == $sha then .overlayHeadCommit = $head else . end)' compatibility.json > "$tmp"
          mv "$tmp" compatibility.json

      - name: Update changelog for new support version
        run: |
          set -euo pipefail
          version="${UPSTREAM_VERSION#v}"
          today=$(date -u +%Y-%m-%d)
          tmp=$(mktemp)
          {
            sed -n '1,6p' CHANGELOG.md
            echo "## [overlay-v${version}] â€” ${today}"
            echo
            echo "### CI/CD"
            echo "- \`ci(auto-compat)\`: auto-compat validated and added support for v${version}"
            echo
            echo "### Chores"
            echo "- \`chore(compat)\`: add candidate support for v${version}"
            echo
            echo "---"
            echo
            sed -n '7,9999p' CHANGELOG.md
          } > "$tmp"
          mv "$tmp" CHANGELOG.md

      - name: Upload candidate artifacts
        uses: actions/upload-artifact@v4
        with:
          name: auto-compat-artifacts-${{ env.UPSTREAM_VERSION }}
          path: out/*

      - name: Cleanup workspace before PR commit
        run: rm -rf work out

      - name: Create pull request for new compatibility support
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          commit-message: "chore(compat): add support candidate for ${{ env.UPSTREAM_VERSION }}"
          branch: "auto/compat-${{ env.UPSTREAM_VERSION }}"
          delete-branch: true
          title: "chore(compat): add support candidate for ${{ env.UPSTREAM_VERSION }}"
          body: |
            Auto-generated compatibility support candidate.

            - Upstream version: `${{ env.UPSTREAM_VERSION }}`
            - Upstream commit: `${{ env.UPSTREAM_SHA }}`
            - Patch set dir: `${{ env.AUTO_PATCHSET_DIR }}`
            - Hard policy: no skip; any failed step fails workflow.
          add-paths: |
            compatibility.json
            CHANGELOG.md
            patches/**
          labels: |
            automation
            compatibility

      - name: Enable auto-merge for compatibility PR
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          pr='${{ steps.cpr.outputs.pull-request-number }}'
          gh pr merge "$pr" --repo "$GITHUB_REPOSITORY" --auto --squash --delete-branch

  mark-failure-residue:
    if: github.event_name != 'pull_request' && failure() && needs.discover.outputs.already_supported != 'true'
    needs: [discover, validate-and-pr]
    runs-on: ubuntu-latest
    steps:
      - name: Mark failure residue state
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          REPO="$GITHUB_REPOSITORY"
          gh api --silent -X POST repos/$REPO/labels -f name='auto-compat-failure-residue' -f color='B60205' -f description='Auto-compat pending failure residue' || true
          title="[auto-compat residue] pending failure chain"
          body="Auto-compat failed and requires autofix before hard path can continue.\n\n- run: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\n- workflow: ${GITHUB_WORKFLOW}"

          issue=$(gh issue list --repo "$REPO" --state open --label auto-compat-failure-residue --limit 1 --json number --jq '.[0].number // empty')
          if [[ -n "$issue" ]]; then
            gh issue comment "$issue" --repo "$REPO" --body "$body"
          else
            new_url=$(gh issue create --repo "$REPO" --title "$title" --body "$body" --label auto-compat-failure-residue)
            issue=$(basename "$new_url")
          fi
          echo "residue issue #$issue"

  trigger-autofix:
    if: always() && github.event_name != 'pull_request' && (needs.discover.outputs.has_failure_residue == 'true' || needs.mark-failure-residue.result == 'success')
    needs: [discover, mark-failure-residue]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger autofix workflow
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          reason="previous-failure-residue"
          if [[ "${{ needs.mark-failure-residue.result }}" == "success" ]]; then
            reason="current-run-failure"
          fi
          gh workflow run autofix-on-failure.yml --repo "$GITHUB_REPOSITORY" \
            -f source_reason="$reason" \
            -f source_workflow="auto-compat" \
            -f source_run_url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" \
            -f source_branch="main"

  clear-failure-residue:
    if: github.event_name != 'pull_request' && success() && needs.discover.outputs.already_supported != 'true'
    needs: [discover, validate-and-pr]
    runs-on: ubuntu-latest
    steps:
      - name: Clear failure residue state
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          REPO="$GITHUB_REPOSITORY"
          issue=$(gh issue list --repo "$REPO" --state open --label auto-compat-failure-residue --limit 1 --json number --jq '.[0].number // empty')
          if [[ -n "$issue" ]]; then
            gh issue comment "$issue" --repo "$REPO" --body "Auto-compat success observed; closing failure residue.\n\n- run: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
            gh issue close "$issue" --repo "$REPO"
          else
            echo "No residue issue to close"
          fi

  pr-verify:
    if: github.event_name == 'pull_request' && startsWith(github.head_ref, 'auto/compat-')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Resolve PR target version and commit
        run: |
          set -euo pipefail
          VERSION="${GITHUB_HEAD_REF#auto/compat-v}"
          SHA=$(jq -r --arg v "$VERSION" '.supported[] | select((.status // "") != "deprecated") | select(.openclawVersion == $v) | .commitSha // empty' compatibility.json | head -n1)
          if [[ -z "${SHA:-}" ]]; then
            echo "No compatible commit found for version $VERSION" >&2
            exit 1
          fi
          echo "UPSTREAM_VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "UPSTREAM_SHA=$SHA" >> "$GITHUB_ENV"

      - name: Setup toolchain
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Checkout upstream openclaw at PR target commit
        uses: actions/checkout@v4
        with:
          repository: openclaw/openclaw
          ref: ${{ env.UPSTREAM_SHA }}
          path: work
          fetch-depth: 0

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git -C ./work config user.name "github-actions[bot]"
          git -C ./work config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Apply overlay patch set for PR
        run: |
          set -euo pipefail
          OVERLAY_CI_ONLY_APPLY=1 ./scripts/apply-personal-patch.sh ./work

      - name: Install dependencies for upstream workspace
        run: |
          cd work
          pnpm install --frozen-lockfile --ignore-scripts

      - name: Run overlay build smoke (required)
        run: |
          cd work
          pnpm -s build

  pr-auto-merge:
    if: github.event_name == 'pull_request' && startsWith(github.head_ref, 'auto/compat-')
    runs-on: ubuntu-latest
    needs: pr-verify
    steps:
      - name: Auto-merge compatible PR when checks are green
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh pr merge "${{ github.event.pull_request.number }}" \
            --repo "$GITHUB_REPOSITORY" \
            --auto --squash --delete-branch
