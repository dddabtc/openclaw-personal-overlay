From 209fe0539d0087024307a8d47dd0d1443a2d9c63 Mon Sep 17 00:00:00 2001
From: zhaod <zhaod@local>
Date: Fri, 20 Feb 2026 15:07:52 -0400
Subject: [PATCH 07/16] fix(control): isolate /stop /status on dedicated
 control lane

---
 .../reply/dispatch-from-config.test.ts        |  61 ++++++-
 src/auto-reply/reply/dispatch-from-config.ts  | 167 +++++++++++++++++-
 src/infra/diagnostic-events.ts                |  11 +-
 src/process/lanes.ts                          |   1 +
 4 files changed, 237 insertions(+), 3 deletions(-)

diff --git a/src/auto-reply/reply/dispatch-from-config.test.ts b/src/auto-reply/reply/dispatch-from-config.test.ts
index 2b6009590..205c0ac2b 100644
--- a/src/auto-reply/reply/dispatch-from-config.test.ts
+++ b/src/auto-reply/reply/dispatch-from-config.test.ts
@@ -21,6 +21,8 @@ const diagnosticMocks = vi.hoisted(() => ({
   logMessageQueued: vi.fn(),
   logMessageProcessed: vi.fn(),
   logSessionStateChange: vi.fn(),
+  logLaneEnqueue: vi.fn(),
+  logLaneDequeue: vi.fn(),
 }));
 const hookMocks = vi.hoisted(() => ({
   runner: {
@@ -93,10 +95,16 @@ vi.mock("./abort.js", () => ({
   },
 }));
 
+vi.mock("../../process/command-queue.js", () => ({
+  enqueueCommandInLane: vi.fn(async (_lane: string, task: () => Promise<unknown>) => await task()),
+}));
+
 vi.mock("../../logging/diagnostic.js", () => ({
   logMessageQueued: diagnosticMocks.logMessageQueued,
   logMessageProcessed: diagnosticMocks.logMessageProcessed,
   logSessionStateChange: diagnosticMocks.logSessionStateChange,
+  logLaneEnqueue: diagnosticMocks.logLaneEnqueue,
+  logLaneDequeue: diagnosticMocks.logLaneDequeue,
 }));
 
 vi.mock("../../plugins/hook-runner-global.js", () => ({
@@ -143,7 +151,7 @@ vi.mock("../../tts/tts.js", () => ({
   resolveTtsConfig: (cfg: OpenClawConfig) => ttsMocks.resolveTtsConfig(cfg),
 }));
 
-const { dispatchReplyFromConfig } = await import("./dispatch-from-config.js");
+const { dispatchReplyFromConfig, matchStrictControlCommand } = await import("./dispatch-from-config.js");
 const { resetInboundDedupe } = await import("./inbound-dedupe.js");
 const { __testing: acpManagerTesting } = await import("../../acp/control-plane/manager.js");
 
@@ -1511,4 +1519,55 @@ describe("dispatchReplyFromConfig", () => {
     expect(blockReplySentTexts).not.toContain("Reasoning:\n_thinking..._");
     expect(blockReplySentTexts).toContain("The answer is 42");
   });
+
+  it("matches only full /stop and /status commands", () => {
+    expect(matchStrictControlCommand(" /stop ")).toBe("stop");
+    expect(matchStrictControlCommand("/status@openclaw_bot")).toBe("status");
+    expect(matchStrictControlCommand("hey /stop")).toBeNull();
+    expect(matchStrictControlCommand("/status now")).toBeNull();
+    expect(matchStrictControlCommand("/stop please")).toBeNull();
+  });
+
+  it("handles /status in control lane without invoking model resolver", async () => {
+    setNoAbort();
+    const dispatcher = createDispatcher();
+    const ctx = buildTestCtx({
+      Provider: "slack",
+      Surface: "slack",
+      CommandBody: "/status",
+      RawBody: "/status",
+      Body: "/status",
+    });
+    const replyResolver = vi.fn(async () => {
+      throw new Error("model unavailable");
+    });
+
+    const result = await dispatchReplyFromConfig({ ctx, cfg: emptyConfig, dispatcher, replyResolver });
+
+    expect(replyResolver).not.toHaveBeenCalled();
+    expect(dispatcher.sendFinalReply).toHaveBeenCalled();
+    expect(result.queuedFinal).toBe(true);
+  });
+
+  it("times out /stop abort dispatch and replies with timeout reason", async () => {
+    mocks.tryFastAbortFromMessage.mockImplementation(
+      () => new Promise<AbortResult>(() => undefined),
+    );
+    const dispatcher = createDispatcher();
+    const ctx = buildTestCtx({
+      Provider: "slack",
+      Surface: "slack",
+      CommandBody: "/stop",
+      RawBody: "/stop",
+      Body: "/stop",
+    });
+
+    await dispatchReplyFromConfig({ ctx, cfg: emptyConfig, dispatcher });
+
+    const calls = (dispatcher.sendFinalReply as ReturnType<typeof vi.fn>).mock.calls;
+    expect(calls.length).toBeGreaterThanOrEqual(2);
+    expect(String(calls[0]?.[0]?.text ?? "")).toContain("Stopping");
+    expect(String(calls[calls.length - 1]?.[0]?.text ?? "")).toContain("timeout");
+  }, 10000);
+
 });
diff --git a/src/auto-reply/reply/dispatch-from-config.ts b/src/auto-reply/reply/dispatch-from-config.ts
index bdecd8763..fac28b74c 100644
--- a/src/auto-reply/reply/dispatch-from-config.ts
+++ b/src/auto-reply/reply/dispatch-from-config.ts
@@ -3,13 +3,15 @@ import type { OpenClawConfig } from "../../config/config.js";
 import { loadSessionStore, resolveStorePath, type SessionEntry } from "../../config/sessions.js";
 import { logVerbose } from "../../globals.js";
 import { createInternalHookEvent, triggerInternalHook } from "../../hooks/internal-hooks.js";
-import { isDiagnosticsEnabled } from "../../infra/diagnostic-events.js";
+import { emitDiagnosticEvent, isDiagnosticsEnabled } from "../../infra/diagnostic-events.js";
 import {
   logMessageProcessed,
   logMessageQueued,
   logSessionStateChange,
 } from "../../logging/diagnostic.js";
 import { getGlobalHookRunner } from "../../plugins/hook-runner-global.js";
+import { enqueueCommandInLane } from "../../process/command-queue.js";
+import { CommandLane } from "../../process/lanes.js";
 import { resolveSendPolicy } from "../../sessions/send-policy.js";
 import { maybeApplyTtsToPayload, normalizeTtsAutoMode, resolveTtsConfig } from "../../tts/tts.js";
 import { getReplyFromConfig } from "../reply.js";
@@ -56,6 +58,63 @@ const isInboundAudioContext = (ctx: FinalizedMsgContext): boolean => {
   return AUDIO_HEADER_RE.test(trimmed);
 };
 
+const STRICT_CONTROL_COMMAND_RE = /^\s*\/(stop|status)(?:@[\w_]+)?\s*$/i;
+const CONTROL_ACK_TIMEOUT_MS = 1_000;
+const CONTROL_ABORT_DISPATCH_TIMEOUT_MS = 3_000;
+
+export function matchStrictControlCommand(text?: string): "stop" | "status" | null {
+  if (!text) {
+    return null;
+  }
+  const match = text.match(STRICT_CONTROL_COMMAND_RE);
+  if (!match) {
+    return null;
+  }
+  const command = match[1]?.toLowerCase();
+  return command === "stop" || command === "status" ? command : null;
+}
+
+function createAbortError(): Error {
+  const err = new Error("control command aborted");
+  err.name = "AbortError";
+  return err;
+}
+
+async function runWithTimeout<T>(params: {
+  timeoutMs: number;
+  signal?: AbortSignal;
+  run: (signal: AbortSignal) => Promise<T>;
+}): Promise<T> {
+  if (params.signal?.aborted) {
+    throw createAbortError();
+  }
+  const controller = new AbortController();
+  const onAbort = () => controller.abort();
+  params.signal?.addEventListener("abort", onAbort, { once: true });
+  const timeout = setTimeout(() => controller.abort(), params.timeoutMs);
+  try {
+    const runPromise = params.run(controller.signal);
+    const abortPromise = new Promise<never>((_, reject) => {
+      controller.signal.addEventListener(
+        "abort",
+        () => {
+          if (params.signal?.aborted) {
+            reject(createAbortError());
+            return;
+          }
+          reject(new Error(`timeout ${params.timeoutMs}ms`));
+        },
+        { once: true },
+      );
+    });
+    return await Promise.race([runPromise, abortPromise]);
+  } finally {
+    clearTimeout(timeout);
+    params.signal?.removeEventListener("abort", onAbort);
+  }
+}
+
+
 const resolveSessionStoreEntry = (
   ctx: FinalizedMsgContext,
   cfg: OpenClawConfig,
@@ -290,6 +349,112 @@ export async function dispatchReplyFromConfig(params: {
     }
   };
 
+  const ingressBody = ctx.CommandBody ?? ctx.RawBody ?? ctx.Body;
+  const strictControlCommand = matchStrictControlCommand(ingressBody);
+  if (strictControlCommand) {
+    emitDiagnosticEvent({
+      type: "command_ingress",
+      sessionKey: ctx.SessionKey,
+      command: strictControlCommand,
+    });
+
+    const controlResult = await enqueueCommandInLane(CommandLane.Control, async () => {
+      emitDiagnosticEvent({
+        type: "control_dequeue",
+        sessionKey: ctx.SessionKey,
+        command: strictControlCommand,
+      });
+
+      const emitPayload = async (payload: ReplyPayload, signal?: AbortSignal): Promise<boolean> => {
+        if (shouldRouteToOriginating && originatingChannel && originatingTo) {
+          const result = await routeReply({
+            payload,
+            channel: originatingChannel,
+            to: originatingTo,
+            sessionKey: ctx.SessionKey,
+            accountId: ctx.AccountId,
+            threadId: ctx.MessageThreadId,
+            cfg,
+            abortSignal: signal,
+          });
+          return result.ok;
+        }
+        return dispatcher.sendFinalReply(payload);
+      };
+
+      let queuedFinal = false;
+      const counts = dispatcher.getQueuedCounts();
+
+      if (strictControlCommand === "stop") {
+        const ackOk = await runWithTimeout({
+          timeoutMs: CONTROL_ACK_TIMEOUT_MS,
+          run: (signal) => emitPayload({ text: "Stopping..." }, signal),
+        });
+        if (ackOk) {
+          counts.final += 1;
+          emitDiagnosticEvent({
+            type: "ack_sent",
+            sessionKey: ctx.SessionKey,
+            command: "stop",
+          });
+        }
+
+        try {
+          const fastAbort = await runWithTimeout({
+            timeoutMs: CONTROL_ABORT_DISPATCH_TIMEOUT_MS,
+            run: () => tryFastAbortFromMessage({ ctx, cfg }),
+          });
+          emitDiagnosticEvent({
+            type: "abort_dispatched",
+            sessionKey: ctx.SessionKey,
+            command: "stop",
+            handled: fastAbort.handled,
+          });
+          const doneText = fastAbort.handled
+            ? formatAbortReplyText(fastAbort.stoppedSubagents)
+            : "⚠️ Stop request was not applied (not authorized or no active target).";
+          queuedFinal = await emitPayload({ text: doneText });
+          if (queuedFinal) {
+            counts.final += 1;
+          }
+        } catch (err) {
+          const reason = String(err);
+          queuedFinal = await emitPayload({
+            text: `⚠️ Stop failed: ${reason.includes("timeout") ? "abort dispatch timeout (3s)" : reason}`,
+          });
+          if (queuedFinal) {
+            counts.final += 1;
+          }
+        }
+
+        return { queuedFinal, counts };
+      }
+
+      const statusOk = await runWithTimeout({
+        timeoutMs: CONTROL_ACK_TIMEOUT_MS,
+        run: (signal) =>
+          emitPayload(
+            {
+              text: "✅ Status: control plane is responsive.",
+            },
+            signal,
+          ),
+      });
+      if (statusOk) {
+        counts.final += 1;
+        emitDiagnosticEvent({
+          type: "status_replied",
+          sessionKey: ctx.SessionKey,
+          command: "status",
+        });
+      }
+      return { queuedFinal: statusOk, counts };
+    });
+
+    recordProcessed("completed", { reason: `control_${strictControlCommand}` });
+    return controlResult;
+  }
+
   markProcessing();
 
   try {
diff --git a/src/infra/diagnostic-events.ts b/src/infra/diagnostic-events.ts
index 5acf0483a..6db61e499 100644
--- a/src/infra/diagnostic-events.ts
+++ b/src/infra/diagnostic-events.ts
@@ -134,6 +134,14 @@ export type DiagnosticHeartbeatEvent = DiagnosticBaseEvent & {
   queued: number;
 };
 
+
+export type DiagnosticControlCommandEvent = DiagnosticBaseEvent & {
+  type: "command_ingress" | "control_dequeue" | "ack_sent" | "abort_dispatched" | "status_replied";
+  sessionKey?: string;
+  command: "stop" | "status";
+  handled?: boolean;
+};
+
 export type DiagnosticToolLoopEvent = DiagnosticBaseEvent & {
   type: "tool.loop";
   sessionKey?: string;
@@ -160,7 +168,8 @@ export type DiagnosticEventPayload =
   | DiagnosticLaneDequeueEvent
   | DiagnosticRunAttemptEvent
   | DiagnosticHeartbeatEvent
-  | DiagnosticToolLoopEvent;
+  | DiagnosticToolLoopEvent
+  | DiagnosticControlCommandEvent;
 
 export type DiagnosticEventInput = DiagnosticEventPayload extends infer Event
   ? Event extends DiagnosticEventPayload
diff --git a/src/process/lanes.ts b/src/process/lanes.ts
index 63ef1f534..512aec04c 100644
--- a/src/process/lanes.ts
+++ b/src/process/lanes.ts
@@ -1,5 +1,6 @@
 export const enum CommandLane {
   Main = "main",
+  Control = "control",
   Cron = "cron",
   Subagent = "subagent",
   Nested = "nested",
-- 
2.25.1

